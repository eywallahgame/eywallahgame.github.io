<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eyvallah Strike</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: Arial, sans-serif; background-color: #2c3e50; color: #ecf0f1; height: 100vh; width: 100vw; }
        .game-container { position: relative; width: 100%; height: 100%; background-color: #34495e; overflow: hidden; }
        .game-info { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #fff; font-size: 1.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
        .ui-panel { position: absolute; top: 10px; right: 10px; z-index: 10; display: flex; flex-direction: column; gap: 10px; }
        .ammo-display, .health-display { padding: 5px 10px; background-color: rgba(0,0,0,0.5); border-radius: 5px; font-size: 1.2em; text-align: center; }
        .game-status { position: absolute; bottom: 10px; top: auto; left: 50%; transform: translateX(-50%); text-align: center; display: none; padding: 10px; background-color: rgba(0,0,0,0.7); border-radius: 5px; }
        #cs2-look-panel { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 99; }
        #cs2-game-controls { display: none; position: absolute; bottom: 10px; left: 10px; right: 10px; justify-content: space-between; align-items: flex-end; z-index: 100; }
        .button { width: 60px; height: 60px; border-radius: 50%; background-color: rgba(44, 62, 80, 0.7); color: #fff; border: none; font-size: 1.5em; line-height: 60px; text-align: center; user-select: none; }
        .joystick-container { position: relative; width: 150px; height: 150px; background-color: rgba(44, 62, 80, 0.5); border-radius: 50%; }
        .joystick-knob { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(189, 195, 199, 0.9); transform: translate(-50%, -50%); }
        .cs2-buttons { display: flex; flex-direction: column; gap: 10px; }
        .reload-button { width: 60px; height: 60px; border-radius: 50%; background-color: rgba(230, 126, 34, 0.7); color: #fff; border: none; font-size: 1.2em; line-height: 60px; text-align: center; user-select: none; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1000;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: white;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
    </style>
</head>
<body>
    <div id="eyvallah-strike-container" class="game-container">
        <div id="crosshair"></div>
        <div class="ui-panel">
            <div class="health-display">Can: <span id="player-health">100</span></div>
            <div class="ammo-display"><span id="current-ammo">30</span> / <span id="max-ammo">30</span></div>
        </div>
        <div class="game-status" id="game-status"></div>
        <div id="cs2-look-panel"></div>
        <div id="cs2-game-controls">
            <div id="cs2-joystick-container" class="joystick-container">
                <div id="cs2-joystick-knob" class="joystick-knob"></div>
            </div>
            <div class="cs2-buttons">
                <button id="jump-button" class="button">Zıpla</button>
                <button id="fire-button" class="button">Ateş Et</button>
                <button id="reload-button" class="reload-button">Şarjör</button>
            </div>
        </div>
    </div>
    <footer>
        <div class="container">
            <p>&copy; 2025 Eyüp Ensar Erkul. Tüm Hakları Saklıdır.</p>
        </div>
    </footer>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.126.0/build/three.module.js';

        const gameContainer = document.getElementById('eyvallah-strike-container');
        const gameStatusElement = document.getElementById('game-status');
        const playerHealthElement = document.getElementById('player-health');
        const currentAmmoElement = document.getElementById('current-ammo');
        const maxAmmoElement = document.getElementById('max-ammo');
        
        const cs2Controls = document.getElementById('cs2-game-controls');
        const moveJoystickContainer = document.getElementById('cs2-joystick-container');
        const fireButton = document.getElementById('fire-button');
        const jumpButton = document.getElementById('jump-button');
        const reloadButton = document.getElementById('reload-button');
        const lookPanel = document.getElementById('cs2-look-panel');
        const crosshair = document.getElementById('crosshair');

        let scene, camera, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let turnLeft = false, turnRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let canJump = false;
        let enemies = [];
        let teammates = [];
        let playerBullets = [];
        let enemyBullets = [];
        let teammateBullets = [];

        const playerHeight = 1.8;
        const playerSpeed = 0.05;
        const turnSpeed = 0.03;
        let playerHealth = 100;
        let currentAmmo = 30;
        const maxAmmo = 30;
        const reloadTime = 2000;
        let isReloading = false;
        const maxEnemies = 5;
        const maxTeammates = 5;
        const mapSize = 200;
        const respawnTime = 3000;

        const teammateSpawnPoints = [
            new THREE.Vector3(80, 0.9, 80),
            new THREE.Vector3(80, 0.9, 60),
            new THREE.Vector3(60, 0.9, 80),
            new THREE.Vector3(60, 0.9, 60),
            new THREE.Vector3(70, 0.9, 70),
            new THREE.Vector3(90, 0.9, 90)
        ];
        const enemySpawnPoints = [
            new THREE.Vector3(-80, 0.9, -80),
            new THREE.Vector3(-80, 0.9, -60),
            new THREE.Vector3(-60, 0.9, -80),
            new THREE.Vector3(-60, 0.9, -60),
            new THREE.Vector3(-70, 0.9, -70),
            new THREE.Vector3(-90, 0.9, -90)
        ];

        let moveJoystickActive = false;
        let moveJoystickCenter = { x: 0, y: 0 };
        let moveJoystickPos = { x: 0, y: 0 };
        const moveJoystickRadius = 75;

        let lookTouchIdentifier = null;
        let prevTouchX = 0;
        let prevTouchY = 0;
        const lookSensitivity = 0.005;

        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = playerHeight;
            camera.position.copy(teammateSpawnPoints[0]);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);
            
            const textureLoader = new THREE.TextureLoader();
            const groundTexture = textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(mapSize / 10, mapSize / 10);
            const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture, color: 0x808080 });
            const groundGeometry = new THREE.PlaneGeometry(mapSize, mapSize);
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            scene.add(ground);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            gameContainer.appendChild(renderer.domElement);
            
            playerHealthElement.innerText = playerHealth;
            currentAmmoElement.innerText = currentAmmo;
            maxAmmoElement.innerText = maxAmmo;

            createCS2Map();
            spawnInitialBots();

            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onResize);
            document.addEventListener('pointerlockchange', onPointerlockChange, false);
            gameContainer.addEventListener('mousedown', onMouseDown, false);
            
            if (isMobileDevice()) {
                cs2Controls.style.display = 'flex';
                lookPanel.addEventListener('touchstart', onLookStart, false);
                lookPanel.addEventListener('touchmove', onLookMove, false);
                lookPanel.addEventListener('touchend', onLookEnd, false);
                fireButton.addEventListener('touchstart', (e) => { e.preventDefault(); onFire(); });
                jumpButton.addEventListener('touchstart', () => { if(canJump) velocity.y = 10; canJump = false; });
                reloadButton.addEventListener('touchstart', onReload);
                crosshair.style.display = 'none';
            } else {
                cs2Controls.style.display = 'none';
                lookPanel.style.display = 'none';
                crosshair.style.display = 'block';
            }

            moveJoystickContainer.addEventListener('touchstart', onMoveJoystickStart, false);
            moveJoystickContainer.addEventListener('touchmove', onMoveJoystickMove, false);
            moveJoystickContainer.addEventListener('touchend', onMoveJoystickEnd, false);

            document.addEventListener('DOMContentLoaded', () => {
                enterFullscreenAndPointerLock();
            });

            animate();
        }
        
        function enterFullscreenAndPointerLock() {
            if (isMobileDevice()) {
                if (!document.fullscreenElement) {
                    gameContainer.requestFullscreen().catch(err => {
                        console.log(`Tam ekran moduna geçilemedi: ${err.message}`);
                    });
                    screen.orientation.lock('landscape').catch(err => {
                        console.log(`Yatay moda geçilemedi: ${err.message}`);
                    });
                }
            } else {
                gameContainer.requestPointerLock();
            }
        }

        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
        }

        function onPointerlockChange() {
            if (document.pointerLockElement === gameContainer) {
                document.addEventListener('mousemove', onMouseMove, false);
                gameStatusElement.style.display = 'none';
                crosshair.style.display = 'block';
            } else {
                document.removeEventListener('mousemove', onMouseMove, false);
                showStatusMessage("Oyun Duraklatıldı. Devam etmek için tıklayın.", 'info');
                crosshair.style.display = 'none';
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function createCS2Map() {
            const textureLoader = new THREE.TextureLoader();
            const wallTexture = textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/concrete.jpg');
            wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(5, 5);
            const wallMaterial = new THREE.MeshLambertMaterial({ map: wallTexture, color: 0xcccccc });

            const boxTexture = textureLoader.load('https://threejsfundamentals.org/threejs/resources/images/box.jpg');
            boxTexture.wrapS = boxTexture.wrapT = THREE.RepeatWrapping;
            boxTexture.repeat.set(2, 2);
            const boxMaterial = new THREE.MeshLambertMaterial({ map: boxTexture, color: 0x95a5a6 });

            const walls = [
                new THREE.Mesh(new THREE.BoxGeometry(mapSize, 10, 1), wallMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(mapSize, 10, 1), wallMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(1, 10, mapSize), wallMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(1, 10, mapSize), wallMaterial)
            ];
            walls[0].position.set(0, 5, -mapSize/2);
            walls[1].position.set(0, 5, mapSize/2);
            walls[2].position.set(-mapSize/2, 5, 0);
            walls[3].position.set(mapSize/2, 5, 0);

            walls.forEach(wall => scene.add(wall));

            const boxes = [
                new THREE.Mesh(new THREE.BoxGeometry(5, 2, 5), boxMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(10, 3, 2), boxMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(3, 3, 10), boxMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(20, 5, 5), boxMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(5, 5, 20), boxMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(10, 4, 10), boxMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(8, 3, 8), boxMaterial),
                new THREE.Mesh(new THREE.BoxGeometry(6, 6, 6), boxMaterial)
            ];
            boxes[0].position.set(20, 1, -15);
            boxes[1].position.set(-10, 1.5, 25);
            boxes[2].position.set(-25, 1.5, -10);
            boxes[3].position.set(10, 2.5, 10);
            boxes[4].position.set(-15, 2.5, -15);
            boxes[5].position.set(40, 2, 40);
            boxes[6].position.set(-40, 1.5, -40);
            boxes[7].position.set(0, 3, 0);

            boxes.forEach(box => scene.add(box));
        }
        
        function createBot(type = 'enemy') {
            const bodyGeometry = new THREE.BoxGeometry(1, 1.8, 1);
            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            
            let bodyMaterial, headMaterial;
            if (type === 'enemy') {
                bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3498db });
                headMaterial = new THREE.MeshLambertMaterial({ color: 0xe74c3c });
            } else {
                bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x2ecc71 });
                headMaterial = new THREE.MeshLambertMaterial({ color: 0xf1c40f });
            }

            const bot = new THREE.Group();
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.4;
            bot.add(body);
            bot.add(head);

            bot.health = 100;
            bot.type = type;
            bot.lastFireTime = Date.now();
            bot.fireRate = Math.random() * 2000 + 1000;
            bot.movementSpeed = Math.random() * 0.03 + 0.01;
            bot.targetPosition = new THREE.Vector3();
            bot.newTargetTime = Date.now();
            bot.state = 'patrol';
            
            return bot;
        }

        function spawnInitialBots() {
            for (let i = 0; i < maxEnemies; i++) {
                spawnBot('enemy');
            }
            for (let i = 0; i < maxTeammates; i++) {
                spawnBot('teammate');
            }
        }
        
        function spawnBot(type = 'enemy') {
            const bot = createBot(type);
            const spawnPoints = type === 'enemy' ? enemySpawnPoints : teammateSpawnPoints;
            const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            bot.position.copy(spawnPoint);
            scene.add(bot);
            if (type === 'enemy') {
                enemies.push(bot);
            } else {
                teammates.push(bot);
            }
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyQ': turnLeft = true; break;
                case 'KeyE': turnRight = true; break;
                case 'KeyL': onFire(); break;
                case 'Space':
                    if (canJump) velocity.y = 10;
                    canJump = false;
                    break;
                case 'KeyR':
                    onReload();
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'KeyQ': turnLeft = false; break;
                case 'KeyE': turnRight = false; break;
            }
        }
        
        function onMouseMove(event) {
            if (document.pointerLockElement === gameContainer) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                camera.rotation.y -= movementX * lookSensitivity;
                const newRotationX = camera.rotation.x - movementY * lookSensitivity;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, newRotationX));
            }
        }

        function onMouseDown(event) {
            if (document.pointerLockElement === gameContainer) {
                if (event.button === 0) {
                    onFire();
                }
            }
        }
        
        function onFire() {
            if (isReloading || currentAmmo <= 0) {
                return;
            }

            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.type = 'player';

            bullet.position.copy(camera.position);
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);

            bullet.velocity = direction.multiplyScalar(50);
            scene.add(bullet);
            playerBullets.push(bullet);

            currentAmmo--;
            currentAmmoElement.innerText = currentAmmo;
        }

        function onReload() {
            if (isReloading || currentAmmo === maxAmmo) return;
            
            isReloading = true;
            showStatusMessage("Şarjör dolduruluyor...", 'info');
            setTimeout(() => {
                currentAmmo = maxAmmo;
                currentAmmoElement.innerText = currentAmmo;
                isReloading = false;
                hideStatusMessage();
            }, reloadTime);
        }
        
        function onMoveJoystickStart(e) {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = moveJoystickContainer.getBoundingClientRect();
            moveJoystickActive = touch.clientX >= rect.left && touch.clientX <= rect.right && touch.clientY >= rect.top && touch.clientY <= rect.bottom;

            if (moveJoystickActive) {
                moveJoystickCenter = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
                onMoveJoystickMove(e);
            }
        }

        function onMoveJoystickMove(e) {
            if (!moveJoystickActive) return;
            e.preventDefault();
            const touch = Array.from(e.changedTouches).find(t => {
                const rect = moveJoystickContainer.getBoundingClientRect();
                return t.clientX >= rect.left && t.clientX <= rect.right && t.clientY >= rect.top && t.clientY <= rect.bottom;
            });
            if (!touch) return;

            let dx = touch.clientX - moveJoystickCenter.x;
            let dy = touch.clientY - moveJoystickCenter.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > moveJoystickRadius) {
                const angle = Math.atan2(dy, dx);
                dx = Math.cos(angle) * moveJoystickRadius;
                dy = Math.sin(angle) * moveJoystickRadius;
            }

            document.getElementById('cs2-joystick-knob').style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;

            moveJoystickPos = { x: dx / moveJoystickRadius, y: -dy / moveJoystickRadius };
        }

        function onMoveJoystickEnd(e) {
            if (!moveJoystickActive) return;
            moveJoystickActive = false;
            document.getElementById('cs2-joystick-knob').style.transform = 'translate(-50%, -50%)';
            moveJoystickPos = { x: 0, y: 0 };
        }
        
        function onLookStart(e) {
            e.preventDefault();
            const touch = e.changedTouches[0];
            lookTouchIdentifier = touch.identifier;
            prevTouchX = touch.clientX;
            prevTouchY = touch.clientY;
        }

        function onLookMove(e) {
            if (lookTouchIdentifier === null) return;
            e.preventDefault();
            const touch = Array.from(e.changedTouches).find(t => t.identifier === lookTouchIdentifier);
            if (!touch) return;

            const dx = touch.clientX - prevTouchX;
            const dy = touch.clientY - prevTouchY;

            camera.rotation.y -= dx * lookSensitivity;
            const newRotationX = camera.rotation.x - dy * lookSensitivity;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, newRotationX));

            prevTouchX = touch.clientX;
            prevTouchY = touch.clientY;
        }

        function onLookEnd(e) {
            if (lookTouchIdentifier === null) return;
            e.preventDefault();
            lookTouchIdentifier = null;
        }

        function showStatusMessage(message, type) {
            gameStatusElement.innerText = message;
            gameStatusElement.style.color = type === 'info' ? '#ecf0f1' : '#e74c3c';
            gameStatusElement.style.display = 'block';
        }

        function hideStatusMessage() {
            gameStatusElement.style.display = 'none';
        }
        
        function animate() {
            requestAnimationFrame(animate);

            const delta = 0.016;

            velocity.y -= 9.8 * 2.0 * delta;

            if (isMobileDevice()) {
                direction.z = moveJoystickPos.y;
                direction.x = moveJoystickPos.x;
            } else {
                if (turnLeft) {
                    camera.rotation.y += turnSpeed;
                }
                if (turnRight) {
                    camera.rotation.y -= turnSpeed;
                }
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
            }

            if (direction.length() > 0) {
                direction.normalize();
            }

            const forwardVector = new THREE.Vector3();
            camera.getWorldDirection(forwardVector);
            forwardVector.y = 0;
            forwardVector.normalize();

            const rightVector = new THREE.Vector3();
            rightVector.crossVectors(camera.up, forwardVector);
            rightVector.normalize();

            const movement = new THREE.Vector3();
            movement.add(forwardVector.multiplyScalar(direction.z * playerSpeed * 60 * delta));
            movement.add(rightVector.multiplyScalar(direction.x * playerSpeed * 60 * delta));

            camera.position.add(movement);
            camera.position.y += velocity.y * delta;

            if (camera.position.y <= playerHeight) {
                velocity.y = 0;
                camera.position.y = playerHeight;
                canJump = true;
            }
            
            updateEnemyBots();
            updateTeammates();
            updateBullets();
            
            renderer.render(scene, camera);
        }

        function findNearestTarget(bot, targetList) {
            let nearestTarget = null;
            let minDistance = Infinity;

            targetList.forEach(target => {
                const distance = bot.position.distanceTo(target.position);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestTarget = target;
                }
            });

            return nearestTarget;
        }

        function updateEnemyBots() {
            enemies.forEach(enemy => {
                const targets = teammates.concat([{ position: camera.position, type: 'player' }]);
                const target = findNearestTarget(enemy, targets);
                if (!target) {
                    enemy.state = 'patrol';
                    return;
                }
                
                const distanceToTarget = enemy.position.distanceTo(target.position);
                const attackDistance = 30;
                const minDistance = 15;

                if (distanceToTarget > attackDistance) {
                    enemy.state = 'patrol';
                } else {
                    enemy.state = 'attack';
                }

                if (enemy.state === 'patrol') {
                    if (Date.now() - enemy.newTargetTime > 5000 || enemy.position.distanceTo(enemy.targetPosition) < 1) {
                        enemy.targetPosition.set(
                            (Math.random() - 0.5) * mapSize * 0.9,
                            enemy.position.y,
                            (Math.random() - 0.5) * mapSize * 0.9
                        );
                        enemy.newTargetTime = Date.now();
                    }
                    const moveDirection = new THREE.Vector3().subVectors(enemy.targetPosition, enemy.position).normalize();
                    enemy.position.add(moveDirection.multiplyScalar(enemy.movementSpeed));
                }
                
                if (enemy.state === 'attack') {
                    // Oyuncuya veya takım arkadaşına dönme
                    enemy.lookAt(new THREE.Vector3(target.position.x, enemy.position.y, target.position.z));
                    
                    // Çok yakınsa geri çekil
                    if(distanceToTarget < minDistance) {
                        const awayDirection = new THREE.Vector3().subVectors(enemy.position, target.position).normalize();
                        enemy.position.add(awayDirection.multiplyScalar(enemy.movementSpeed));
                    }
                    
                    // Ateş etme
                    if (Date.now() - enemy.lastFireTime > enemy.fireRate) {
                        fireBotBullet(enemy, target);
                        enemy.lastFireTime = Date.now();
                    }
                }
            });
        }
        
        function updateTeammates() {
            teammates.forEach(teammate => {
                const target = findNearestTarget(teammate, enemies);
                if (!target) {
                    teammate.state = 'patrol';
                    return;
                }

                const distanceToTarget = teammate.position.distanceTo(target.position);
                const attackDistance = 30;
                const minDistance = 15;

                if (distanceToTarget > attackDistance) {
                    teammate.state = 'patrol';
                } else {
                    teammate.state = 'attack';
                }

                if (teammate.state === 'patrol') {
                    if (Date.now() - teammate.newTargetTime > 5000 || teammate.position.distanceTo(teammate.targetPosition) < 1) {
                        teammate.targetPosition.set(
                            (Math.random() - 0.5) * mapSize * 0.9,
                            teammate.position.y,
                            (Math.random() - 0.5) * mapSize * 0.9
                        );
                        teammate.newTargetTime = Date.now();
                    }
                    const moveDirection = new THREE.Vector3().subVectors(teammate.targetPosition, teammate.position).normalize();
                    teammate.position.add(moveDirection.multiplyScalar(teammate.movementSpeed));
                }

                if (teammate.state === 'attack') {
                    teammate.lookAt(new THREE.Vector3(target.position.x, teammate.position.y, target.position.z));

                    if(distanceToTarget < minDistance) {
                        const awayDirection = new THREE.Vector3().subVectors(teammate.position, target.position).normalize();
                        teammate.position.add(awayDirection.multiplyScalar(teammate.movementSpeed));
                    }

                    if (Date.now() - teammate.lastFireTime > teammate.fireRate) {
                        fireBotBullet(teammate, target);
                        teammate.lastFireTime = Date.now();
                    }
                }
            });
        }

        function fireBotBullet(bot, target) {
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: bot.type === 'enemy' ? 0xe74c3c : 0x27ae60 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.type = bot.type;

            bullet.position.copy(bot.position);
            bullet.position.y = 1.2;
            const direction = new THREE.Vector3().subVectors(target.position, bot.position).normalize();
            bullet.velocity = direction.multiplyScalar(20);
            scene.add(bullet);
            
            if (bot.type === 'enemy') {
                enemyBullets.push(bullet);
            } else {
                teammateBullets.push(bullet);
            }
        }
        
        function handleRespawn(type) {
            setTimeout(() => {
                spawnBot(type);
            }, respawnTime);
        }

        function handlePlayerDeath() {
            showStatusMessage("Öldün! Yeniden doğuyorsun...", 'error');
            setTimeout(() => {
                const spawnPoint = teammateSpawnPoints[Math.floor(Math.random() * teammateSpawnPoints.length)];
                camera.position.copy(spawnPoint);
                playerHealth = 100;
                playerHealthElement.innerText = playerHealth;
                hideStatusMessage();
            }, respawnTime);
        }
        
        function updateBullets() {
            // Player bullets
            for(let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                bullet.position.add(bullet.velocity.clone().multiplyScalar(0.016));
                
                if (bullet.position.distanceTo(camera.position) > 300) {
                    scene.remove(bullet);
                    playerBullets.splice(i, 1);
                    continue;
                }
                
                let hitTarget = false;
                
                for(let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (bullet.position.distanceTo(enemy.position) < 1.5) {
                        enemy.health -= 25;
                        if (enemy.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(j, 1);
                            handleRespawn('enemy');
                        }
                        scene.remove(bullet);
                        playerBullets.splice(i, 1);
                        hitTarget = true;
                        break;
                    }
                }
                if (hitTarget) continue;
            }
            
            // Enemy bullets
            for(let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.position.add(bullet.velocity.clone().multiplyScalar(0.016));

                if (bullet.position.distanceTo(camera.position) > 300) {
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                if (bullet.position.distanceTo(camera.position) < 0.5) {
                    playerHealth -= 10;
                    playerHealthElement.innerText = playerHealth;
                    if (playerHealth <= 0) {
                        handlePlayerDeath();
                        return;
                    }
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                let hitTeammate = false;
                for(let j = teammates.length - 1; j >= 0; j--) {
                    const teammate = teammates[j];
                    if (bullet.position.distanceTo(teammate.position) < 1.5) {
                        teammate.health -= 10;
                        if (teammate.health <= 0) {
                            scene.remove(teammate);
                            teammates.splice(j, 1);
                            handleRespawn('teammate');
                        }
                        scene.remove(bullet);
                        enemyBullets.splice(i, 1);
                        hitTeammate = true;
                        break;
                    }
                }
                if (hitTeammate) continue;
            }

            // Teammate bullets
            for(let i = teammateBullets.length - 1; i >= 0; i--) {
                const bullet = teammateBullets[i];
                bullet.position.add(bullet.velocity.clone().multiplyScalar(0.016));

                if (bullet.position.distanceTo(camera.position) > 300) {
                    scene.remove(bullet);
                    teammateBullets.splice(i, 1);
                    continue;
                }

                let hitEnemy = false;
                for(let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (bullet.position.distanceTo(enemy.position) < 1.5) {
                        enemy.health -= 25;
                        if (enemy.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(j, 1);
                            handleRespawn('enemy');
                        }
                        scene.remove(bullet);
                        teammateBullets.splice(i, 1);
                        hitEnemy = true;
                        break;
                    }
                }
                if (hitEnemy) continue;
            }
        }
        
        initGame();
    </script>
</body>
</html>
