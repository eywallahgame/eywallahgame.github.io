<style>
    /* Oyunun sayfa üzerindeki görünümünü ayarlar */
    #game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        margin-top: 50px;
        background-color: #1a1a1a;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }
    #game-container h2 {
        color: #ff6f00;
        font-family: 'Segoe UI', sans-serif;
        margin-bottom: 20px;
    }
    #gameCanvas {
        border: 2px solid #5a5a5a;
        background-color: #3f3f3f;
        cursor: crosshair;
    }
    #game-info {
        display: flex;
        justify-content: space-between;
        width: 800px; /* Canvas genişliği ile aynı */
        margin-top: 10px;
        color: white;
        font-family: monospace;
        font-size: 16px;
    }
</style>

<div id="game-container">
    <h2>CS2 Mini-Oyun (Prototip)</h2>
    <div id="game-info">
        <div>Puan: <span id="score">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let score = 0;
    const player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 20,
        color: '#ffffff',
        speed: 5
    };

    const bullets = [];
    const enemies = [];
    const bulletSpeed = 10;
    const enemySpeed = 1;
    let lastSpawnTime = 0;
    const spawnInterval = 1000;
    let lastFrameTime = 0;

    const keys = {};
    let mouseX = player.x;
    let mouseY = player.y;

    document.addEventListener('keydown', (e) => {
        keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener('click', () => {
        const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
        const bullet = {
            x: player.x,
            y: player.y,
            size: 5,
            color: '#ffdd00',
            dx: Math.cos(angle) * bulletSpeed,
            dy: Math.sin(angle) * bulletSpeed
        };
        bullets.push(bullet);
    });

    function gameLoop(currentTime) {
        const deltaTime = currentTime - lastFrameTime;
        const fps = Math.round(1000 / deltaTime);
        document.getElementById('fps').textContent = fps;
        lastFrameTime = currentTime;

        update(currentTime);
        draw();
        requestAnimationFrame(gameLoop);
    }

    function update(currentTime) {
        if (keys['w'] || keys['W']) player.y -= player.speed;
        if (keys['s'] || keys['S']) player.y += player.speed;
        if (keys['a'] || keys['A']) player.x -= player.speed;
        if (keys['d'] || keys['D']) player.x += player.speed;

        player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x));
        player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y));

        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            bullet.x += bullet.dx;
            bullet.y += bullet.dy;
            if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                bullets.splice(i, 1);
            }
        }

        if (currentTime - lastSpawnTime > spawnInterval) {
            spawnEnemy();
            lastSpawnTime = currentTime;
        }

        for (const enemy of enemies) {
            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            enemy.x += Math.cos(angle) * enemySpeed;
            enemy.y += Math.sin(angle) * enemySpeed;
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                const dist = Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y);
                if (dist < bullet.size + enemy.size) {
                    bullets.splice(i, 1);
                    enemies.splice(j, 1);
                    score += 10;
                    document.getElementById('score').textContent = score;
                    break;
                }
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Oyuncuyu çiz
        const angleToMouse = Math.atan2(mouseY - player.y, mouseX - player.x);
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(angleToMouse);
        ctx.fillStyle = player.color;
        ctx.fillRect(-player.size / 2, -player.size / 2, player.size, player.size); // Kare oyuncu
        ctx.restore();

        for (const bullet of bullets) {
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
            ctx.fillStyle = bullet.color;
            ctx.fill();
            ctx.closePath();
        }

        for (const enemy of enemies) {
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
            ctx.fillStyle = '#ff6f00'; // CS2 logosunun turuncu rengi
            ctx.fill();
            ctx.closePath();
        }
    }

    function spawnEnemy() {
        const size = 15;
        let x, y;
        if (Math.random() > 0.5) {
            x = Math.random() > 0.5 ? -size : canvas.width + size;
            y = Math.random() * canvas.height;
        } else {
            x = Math.random() * canvas.width;
            y = Math.random() > 0.5 ? -size : canvas.height + size;
        }

        enemies.push({
            x: x,
            y: y,
            size: size,
            color: 'red',
            speed: enemySpeed
        });
    }

    requestAnimationFrame(gameLoop);
</script>
